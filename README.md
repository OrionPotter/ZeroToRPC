# ZeroToRPC
# 一步步打造你的RPC框架

## **版本1.0：项目起航**

### **主要功能**

- **项目搭建**：使用 Maven 搭建 Java 项目，引入必要的依赖（如 Lombok）。
- **基础结构**：创建基本的项目目录结构，包括 `service`、`model`、`client`、`server` 等模块。

### **背景知识**

- Java 基础
- Maven 项目管理
- Lombok 使用

### **痛点**

1. **缺乏RPC框架结构**：项目初始阶段仅有简单的类和接口，缺乏明确的RPC通信框架。
2. **基础功能有限**：尚未实现任何RPC相关的功能，无法进行远程方法调用。

### **优化方向**

- 搭建基础项目结构，为后续RPC功能的实现打下基础。
- 引入必要的依赖，简化开发过程。

---

## **版本2.0：基础通信**

### **主要功能**

- **基本通信机制**：实现客户端与服务器之间的TCP连接。
- **简单的请求-响应模式**：客户端发送请求，服务器返回响应。
- **单一服务实现**：仅支持一个 `UserService` 接口及其实现。

### **背景知识**

- Java Socket 编程入门
- 基本的序列化与反序列化（Java原生序列化）
- 多线程基础（服务端为每个连接启动新线程）

### **痛点**

1. **功能单一**：只能调用服务端唯一确定的方法，缺乏通用性。
2. **返回值类型受限**：仅支持 `User` 对象作为返回值，无法返回其他类型。
3. **客户端通用性差**：客户端绑定特定的服务、主机和端口，缺乏灵活性。

### **优化方向**

- 抽象请求和响应的消息格式，支持多种方法调用和返回类型。
- 增强客户端的通用性，通过动态代理实现不同服务的调用。
- 为未来支持多服务和多类型返回值做准备。

---

## **版本3.0：通用消息与动态代理**

### **主要功能**

- **通用的 `RPCRequest` 和 `RPCResponse`**：定义统一的请求和响应格式，支持多种方法和返回类型。
- **动态代理**：客户端通过动态代理封装对远程方法的调用，提升通用性和灵活性。
- **多方法支持**：服务端能够处理多个方法调用，客户端能够调用不同的方法。

### **背景知识**

- Java 反射
- 动态代理（JDK代理）
- 统一消息格式设计

### **痛点**

1. **服务单一**：仍然限于单一服务接口，无法扩展多个服务。
2. **单线程处理**：服务端采用BIOSocket处理请求，难以应对高并发。
3. **错误处理不足**：缺乏完善的错误处理机制，可能导致系统不稳定。

### **优化方向**

- 抽象并支持多服务接口的注册与调用。
- 引入线程池或异步处理机制，提高服务端并发处理能力。
- 增强错误处理，提供更详细的错误信息和恢复策略。

---

## **版本4.0：多服务与线程池**

### **主要功能**

- **多服务支持**：服务端能够注册并提供多个服务接口（如 `UserService`、`BlogService`）。
- **服务注册中心**：引入 `ServiceProvider` 类，通过 `Map` 维护接口名与实现类的映射。
- **线程池优化**：服务端采用线程池管理请求处理，提高并发性能。

### **背景知识**

- 代码解耦与单一职责原则
- 线程池的使用与管理
- 服务接口的动态注册

### **痛点**

1. **单线程瓶颈**：尽管引入了线程池，但基于传统BIO的网络通信性能仍然有限。
2. **服务注册复杂度**：手动管理服务接口与实现类的映射增加了维护难度。
3. **资源管理问题**：线程池的配置和管理可能导致资源泄漏或竞争条件。

### **优化方向**

- 进一步优化线程池配置，提高资源利用率。
- 引入更高效的网络通信框架（如 Netty），替代传统BIO。
- 自动化服务接口的注册与管理，提升灵活性与扩展性。

---

## **版本5.0：Netty加持**

### **主要功能**

- **Netty集成**：使用 Netty 作为高性能的网络通信框架，替代传统BIO。
- **重构客户端与服务器**：实现基于Netty的 `NettyRPCClient` 和 `NettyRPCServer`，提升通信效率。
- **统一通信接口**：通过抽象网络传输层，实现不同传输方式的无缝切换。

### **背景知识**

- Netty框架的基本使用
- NIO与非阻塞式通信
- Netty的编解码机制

### **痛点**

1. **Java原生序列化效率低**：Java自带的序列化方式性能较低，字节流冗长。
2. **异步处理复杂**：Netty的异步特性增加了编程复杂度，需合理设计回调机制。
3. **序列化器耦合**：当前使用Java原生序列化，难以支持多种序列化方式。

### **优化方向**

- 引入更高效的序列化协议（如 Protobuf、JSON）。
- 设计统一的序列化接口，支持多种序列化器的扩展。
- 优化Netty的编码器与解码器，提升数据传输效率。

---

## **版本6.0：自定义协议与多序列化**

### **主要功能**

- **自定义协议设计**：设计并实现自定义的消息格式，包含消息类型、序列化方式和消息长度，解决粘包问题。
- **多种序列化器**：实现 `ObjectSerializer`（Java原生序列化）和 `JsonSerializer`（基于JSON的序列化），可扩展更多序列化方式。
- **统一编码解码**：在Netty的管道中引入自定义的编码器 (`MyEncode`) 和解码器 (`MyDecode`)，替代Netty自带的 `ObjectEncoder` 和 `ObjectDecoder`。

### **背景知识**

- 自定义协议设计原则
- 各种序列化方式的比较与应用
- Netty的编解码机制

### **痛点**

1. **序列化效率与通用性不足**：Java原生序列化效率低下，且不够通用。
2. **粘包问题**：需要通过自定义协议的消息长度字段解决Netty中的粘包问题。
3. **序列化器扩展困难**：现有的序列化器接口设计尚未完善，扩展新的序列化方式较为复杂。

### **优化方向**

- 进一步优化序列化器接口设计，确保扩展性和通用性。
- 添加更多高效的序列化方式（如 Protobuf、Kryo），提升整体性能。
- 优化自定义协议的设计，增加更多消息类型支持（如心跳机制）。

---

## **版本7.0：服务注册与发现**

### **主要功能**

- **引入Zookeeper作为注册中心**：使用Zookeeper实现服务的注册与发现。
- **服务注册接口**：定义 `ServiceRegister` 接口及其实现类 `ZkServiceRegister`，实现服务的注册与查询。
- **服务端注册服务**：服务端在启动时，将自身的服务接口及地址注册到Zookeeper中。
- **客户端服务发现**：客户端在发送请求前，从Zookeeper中查询目标服务的地址，进行连接。

### **背景知识**

- Zookeeper的基本概念与安装
- Apache Curator框架的使用
- 分布式服务注册与发现机制

### **痛点**

1. **负载均衡基础薄弱**：单一服务实例可能成为瓶颈，缺乏负载均衡策略。
2. **服务地址固定**：客户端需预先知道服务端地址，缺乏动态获取的能力。
3. **高可用性不足**：注册中心单点可能成为系统的单点故障。

### **优化方向**

- 实现负载均衡策略，分散请求至多个服务实例。
- 优化服务发现机制，支持动态更新服务地址列表。
- 增加注册中心的高可用性，通过集群部署提升系统可靠性。

---

## **版本8.0：负载均衡策略**

### **主要功能**

- **负载均衡接口**：定义 `LoadBalance` 接口，支持不同的负载均衡策略。
- **负载均衡策略实现**：实现 `RandomLoadBalance`（随机策略）和 `RoundLoadBalance`（轮询策略）。
- **集成负载均衡到服务发现**：在客户端服务发现时，使用负载均衡策略从多个服务实例中选择一个目标地址进行请求。

### **背景知识**

- 负载均衡的基本原理与常见策略
- 设计模式中的策略模式
- 并发与线程安全（特别是轮询策略的计数器管理）

### **痛点**

1. **负载均衡策略有限**：当前仅支持随机与轮询，缺乏更多灵活的策略。
2. **负载均衡状态不共享**：轮询策略的计数器在多实例客户端中可能不一致，影响负载均衡效果。
3. **服务实例更新未实时反映**：动态添加或移除服务实例后，客户端未能及时更新负载均衡状态。

### **优化方向**

- 增加更多的负载均衡策略（如最少连接、加权轮询等）。
- 实现线程安全的负载均衡状态管理，确保在多线程环境下的准确性。
- 引入订阅机制，实时监听服务实例的变化，动态调整负载均衡状态。

---

## **版本9.0：动态服务管理**

### **主要功能**

- **客户端缓存服务地址列表**：客户端在首次查询服务时，从Zookeeper获取所有可用的服务实例地址，并缓存于本地。
- **Zookeeper监听服务提供者状态**：客户端通过Zookeeper的监听机制，实时感知服务实例的上线与下线，动态更新本地缓存。
- **动态更新负载均衡**：根据服务实例的变化，动态调整负载均衡策略中的服务地址列表。

### **背景知识**

- Zookeeper的Watcher机制
- 本地缓存与并发访问控制
- 资源同步与状态管理

### **痛点**

1. **服务地址实时性不足**：缺乏实时监听，导致客户端缓存的服务地址可能过时。
2. **缓存一致性问题**：在多线程环境下，服务地址缓存的更新可能导致数据不一致。
3. **负载均衡状态刷新延迟**：服务实例变化与负载均衡策略的更新可能存在延迟，影响请求分配。

### **优化方向**

- 优化Zookeeper监听机制，确保服务实例变化能够即时反映到客户端缓存中。
- 使用线程安全的数据结构（如 `ConcurrentHashMap`）管理服务地址缓存，保证一致性。
- 实现高效的负载均衡状态刷新机制，最小化延迟影响。

---

## **版本10.0：跨语言通信与Protobuf支持（待实现）**

### **主要功能**

- **跨语言支持**：引入Protobuf作为接口定义语言，实现不同编程语言间的RPC通信。
- **Protobuf序列化**：使用Protobuf替代JSON和Java原生序列化，提升序列化与反序列化效率。
- **多语言客户端与服务器**：提供多种语言（如 Python、Go）的客户端和服务器实现，增强系统的兼容性。

### **背景知识**

- Protocol Buffers (Protobuf) 的基本使用与定义文件编写
- 跨语言通信协议设计
- 多语言环境下的序列化与反序列化机制

### **痛点**

1. **跨语言通信复杂度高**：不同语言间的数据结构与协议兼容性需要仔细设计与实现。
2. **Protobuf定义与维护**：需要维护统一的Protobuf接口定义文件，确保各语言实现的一致性。
3. **多语言支持的测试与调试**：跨语言环境下，测试与调试变得更加复杂，需设计有效的测试策略。

### **优化方向**

- 设计清晰的Protobuf接口定义文件，确保不同语言实现的一致性。
- 引入自动化工具链，简化Protobuf文件的编译与生成过程。
- 实现全面的跨语言测试案例，确保系统在多语言环境下的稳定性与性能。

---

## **未来版本：高级特性与系统优化**

### **主要功能**

- **服务熔断与容错机制**：引入断路器模式，防止连锁故障，提升系统的稳定性。
- **高可用性设计**：设计服务端集群，实现负载均衡与故障转移，确保服务的高可用性。
- **分布式追踪与监控**：集成分布式追踪工具（如 Zipkin、Jaeger），监控RPC调用链路，优化性能。
- **安全机制**：引入认证与授权机制，确保RPC调用的安全性与合法性。

### **背景知识**

- 分布式系统中的容错与熔断设计
- 分布式追踪系统的集成与应用
- 安全协议与加密机制

### **痛点**

1. **系统稳定性不足**：在高负载或部分服务故障时，系统容易出现连锁反应。
2. **缺乏深入的监控与追踪**：难以及时发现性能瓶颈与故障点，影响优化效果。
3. **安全风险**：缺乏有效的认证与授权机制，存在潜在的安全隐患。

### **优化方向**

- 实现断路器与重试机制，提升系统的容错能力。
- 集成分布式追踪与监控工具，深入分析RPC调用链路与性能。
- 设计并实现全面的安全机制，保护RPC调用的安全性。

---

# **总结**

通过逐步迭代，`ZeroToRPC` 项目从最初的基础RPC实现，逐步演进为一个高性能、通用且可扩展的RPC框架。每个版本在解决前一版本的痛点基础上，引入新的功能和优化，确保框架能够满足不断增长的需求和复杂性。以下是项目迭代的关键里程碑：

1. **项目起航**：初始化项目结构，搭建基础环境。
2. **基础通信**：实现最简单的RPC调用，建立基础通信机制。
3. **通用消息与动态代理**：提升通用性，支持多方法调用和多服务接口。
4. **多服务与线程池**：实现多服务支持，优化并发处理性能。
5. **Netty加持**：引入Netty，提升网络通信性能。
6. **自定义协议与多序列化**：设计自定义协议，支持多种序列化方式，解决粘包问题。
7. **服务注册与发现**：集成Zookeeper，实现服务的动态注册与发现。
8. **负载均衡策略**：实现多种负载均衡策略，分散服务实例压力。
9. **动态服务管理**：优化客户端的服务发现与地址缓存，实时更新服务状态。
10. **跨语言通信与Protobuf支持**：扩展RPC框架的语言兼容性，提升序列化性能。
11. **高级特性与系统优化**：引入容错、监控、安全等高级特性，提升系统的稳定性与安全性。

通过这种循序渐进的开发方式，`ZeroToRPC` 项目不仅提升了RPC框架的核心功能和性能，也为未来的功能扩展和技术升级奠定了坚实的基础。这种从简到繁、逐步优化的过程，使得新手开发者能够更易于理解和掌握RPC框架的实现原理与开发技巧。


